/*
通道（Channel）

通道（Channel）是用于 Goroutine 之间的数据传递。

通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。

使用 make 函数创建一个 channel，使用 <- 操作符发送和接收数据。如果未指定方向，则为双向通道。

ch <- v    // 把 v 发送到通道 ch
v := <-ch  // 从 ch 接收数据

	// 并把值赋给 v
*/
package study_case

import "fmt"

// 声明一个通道，使用chan关键字，通道在使用前必须先创建
// ch := make(chan int)

//功能：并发计算数组各部分元素和，展示goroutine和channel的配合使用。
// sum 计算整数切片中所有元素的和，并将结果发送到指定的通道
// 参数:
//   s []int - 需要求和的整数切片
//   c chan int - 用于发送计算结果的通道
func sum(s []int, c chan int) {
	sum := 0
	// 遍历切片中的每个元素并累加
	for _, v := range s {
		sum += v
	}
	// 把sum发送到通道c
	c <- sum
}

/*
Go 遍历通道与关闭通道
	Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：

	v, ok := <-ch
	如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。


*/
func fibonacci(n int, c chan int) {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		c <- x
		x, y = y, x+y
	}
	close(c) // 关闭通道，表示不再发送数据
}

func ChannelCase() {

	/*channel 基础案例*/
	s := []int{7, 2, 8, -9, 4, 0}

	// 创建一个用于接收计算结果的通道
	c := make(chan int)

	// 启动两个goroutine分别计算切片前半部分和后半部分的和
	go sum(s[:len(s)/2], c) // 计算前半部分
	go sum(s[len(s)/2:], c) // 计算后半部分

	// 从通道中接收两个计算结果
	x, y := <-c, <-c
	fmt.Println(x, y, x+y)

	/*
		通道缓冲区
		通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：
		ch := make(chan int, 100)

		带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，
		就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，
		而不是立刻需要接收端去获取数据。

		不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，
		否则缓冲区一满，数据发送端就无法再发送数据了。

		注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。
		如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；
		如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。
		接收方在有值可以接收之前会一直阻塞。
	*/
	// 该代码演示了带缓冲通道的基本使用方式
	// 创建一个容量为2的整型通道，可以无阻塞地发送两个值
	ch2 := make(chan int, 2)
	ch2 <- 1           // 向通道发送第一个值
	ch2 <- 2           // 向通道发送第二个值
	fmt.Println(<-ch2) // 从通道接收第一个值并打印
	fmt.Println(<-ch2) // 从通道接收第二个值并打印

	/*Go 遍历通道与关闭通道*/
	ch3 := make(chan int, 10)
	go fibonacci(cap(ch3), ch3)

	for i := range ch3 {
		// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个
		// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据
		// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不
		// 会结束，从而在接收第 11 个数据的时候就阻塞了。
		fmt.Println(i)
	}

}
